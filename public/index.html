<!-- Save this as public/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SuperCollider MIDI Controller</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 20px;
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #333;
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .connected {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .keyboard {
            display: flex;
            position: relative;
            height: 150px;
            margin: 20px 0;
            user-select: none;
        }
        .key {
            background-color: white;
            border: 1px solid #ccc;
            flex: 1;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 10px;
            cursor: pointer;
            border-radius: 0 0 4px 4px;
            position: relative;
            z-index: 1;
        }
        .key.black {
            background-color: #333;
            color: white;
            height: 60%;
            width: 60%;
            margin-left: -30%;
            margin-right: -30%;
            z-index: 2;
        }
        .key.active {
            background-color: #a7d7f9;
        }
        .key.black.active {
            background-color: #4a94ce;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 0;
        }
        button:hover {
            background-color: #45a049;
        }
        .slider-container {
            margin: 15px 0;
        }
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        .log {
            height: 150px;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-family: monospace;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>SuperCollider MIDI Controller</h1>
    
    <div class="container">
        <h2>Connection</h2>
        <div id="websocketStatus" class="status disconnected">WebSocket: Not connected</div>
        <div id="midiStatus" class="status disconnected">MIDI: Not connected</div>
        <button id="connectWS">Connect to OSC Bridge</button>
        <button id="connectMIDI">Enable Web MIDI</button>
    </div>
    
    <div class="container">
        <h2>Virtual Piano</h2>
        <div id="keyboard" class="keyboard">
            <!-- Keys will be generated by JavaScript -->
        </div>
    </div>
    
    <div class="container">
        <h2>MIDI Controllers</h2>
        <div class="slider-container">
            <label for="modulation">Modulation (CC 1): <span id="modValue">0</span></label>
            <input type="range" id="modulation" class="slider" min="0" max="127" value="0">
        </div>
        <div class="slider-container">
            <label for="expression">Expression (CC 11): <span id="exprValue">0</span></label>
            <input type="range" id="expression" class="slider" min="0" max="127" value="0">
        </div>
    </div>
    
    <div class="container">
        <h2>Log</h2>
        <div id="log" class="log"></div>
        <button id="clearLog">Clear Log</button>
    </div>

    <script>
        // Global variables
        let socket = null;
        let midiAccess = null;
        let activeNotes = new Set();
        
        // DOM elements
        const logElement = document.getElementById('log');
        const connectWSButton = document.getElementById('connectWS');
        const connectMIDIButton = document.getElementById('connectMIDI');
        const websocketStatus = document.getElementById('websocketStatus');
        const midiStatus = document.getElementById('midiStatus');
        
        // Connect to WebSocket server
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host;
            const wsUrl = `${protocol}//${host}`;
            
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }
            
            logMessage('Connecting to WebSocket...');
            updateStatus(websocketStatus, 'connecting', 'WebSocket: Connecting...');
            
            try {
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    logMessage('WebSocket connected');
                    updateStatus(websocketStatus, 'connected', 'WebSocket: Connected');
                    connectWSButton.textContent = 'Disconnect';
                };
                
                socket.onclose = () => {
                    logMessage('WebSocket disconnected');
                    updateStatus(websocketStatus, 'disconnected', 'WebSocket: Disconnected');
                    connectWSButton.textContent = 'Connect to OSC Bridge';
                };
                
                socket.onerror = (error) => {
                    logMessage(`WebSocket error: ${error.message || 'Unknown error'}`);
                    updateStatus(websocketStatus, 'disconnected', 'WebSocket: Connection error');
                };
                
                socket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        logMessage(`Received: ${JSON.stringify(data)}`);
                        
                        // Process different message types
                        if (data.type === 'osc') {
                            processOscMessage(data);
                        }
                    } catch (err) {
                        logMessage(`Error parsing message: ${err.message}`);
                    }
                };
            } catch (err) {
                logMessage(`Error creating WebSocket: ${err.message}`);
                updateStatus(websocketStatus, 'disconnected', 'WebSocket: Failed to connect');
            }
        }
        
        // Process incoming OSC messages
        function processOscMessage(data) {
            // Handle specific OSC messages from SuperCollider
            if (data.address === '/note/feedback') {
                const note = data.args[0].value;
                const isOn = data.args[1].value > 0;
                
                // Update key visualization
                const key = document.querySelector(`.key[data-note="${note}"]`);
                if (key) {
                    if (isOn) key.classList.add('active');
                    else key.classList.remove('active');
                }
            }
        }
        
        // Initialize Web MIDI API
        function initMIDI() {
            if (navigator.requestMIDIAccess) {
                logMessage('Requesting MIDI access...');
                updateStatus(midiStatus, 'connecting', 'MIDI: Requesting access...');
                
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                logMessage('Web MIDI API not supported in this browser');
                updateStatus(midiStatus, 'disconnected', 'MIDI: Not supported in this browser');
            }
        }
        
        // MIDI initialization successful
        function onMIDISuccess(access) {
            midiAccess = access;
            logMessage('MIDI access granted');
            updateStatus(midiStatus, 'connected', 'MIDI: Connected');
            connectMIDIButton.textContent = 'MIDI Enabled';
            
            // Connect to all MIDI inputs
            const inputs = midiAccess.inputs.values();
            for (let input = inputs.next(); input && !input.done; input = inputs.next()) {
                input.value.onmidimessage = onMIDIMessage;
                logMessage(`Connected to MIDI input: ${input.value.name || 'Unknown device'}`);
            }
            
            // Handle connection state changes
            midiAccess.onstatechange = (e) => {
                logMessage(`MIDI connection state change: ${e.port.name} ${e.port.state}`);
                
                // Update UI based on available inputs
                if ([...midiAccess.inputs.values()].length === 0) {
                    updateStatus(midiStatus, 'disconnected', 'MIDI: No devices connected');
                } else {
                    updateStatus(midiStatus, 'connected', 'MIDI: Connected');
                }
            };
        }
        
        // MIDI initialization failed
        function onMIDIFailure(error) {
            logMessage(`MIDI access failed: ${error.message || error}`);
            updateStatus(midiStatus, 'disconnected', 'MIDI: Access denied');
        }
        
        // Handle incoming MIDI messages
        function onMIDIMessage(message) {
            const data = message.data;
            const cmd = data[0] >> 4;
            const channel = data[0] & 0xf;
            const noteNumber = data[1];
            const velocity = data[2];
            
            logMessage(`MIDI message: [${Array.from(data).join(', ')}]`);
            
            // Note on
            if (cmd === 9 && velocity > 0) {
                noteOn(noteNumber, velocity);
            } 
            // Note off
            else if (cmd === 8 || (cmd === 9 && velocity === 0)) {
                noteOff(noteNumber);
            }
            // Control change
            else if (cmd === 11) {
                controlChange(noteNumber, velocity);
                
                // Update UI for certain CCs
                if (noteNumber === 1) { // Modulation
                    document.getElementById('modulation').value = velocity;
                    document.getElementById('modValue').textContent = velocity;
                } else if (noteNumber === 11) { // Expression
                    document.getElementById('expression').value = velocity;
                    document.getElementById('exprValue').textContent = velocity;
                }
            }
        }
        
        // Send MIDI note on
        function noteOn(note, velocity) {
            activeNotes.add(note);
            sendOSC('/midi/noteon', [note, velocity]);
            
            // Update keyboard UI
            const key = document.querySelector(`.key[data-note="${note}"]`);
            if (key) {
                key.classList.add('active');
            }
        }
        
        // Send MIDI note off
        function noteOff(note) {
            activeNotes.delete(note);
            sendOSC('/midi/noteoff', [note, 0]);
            
            // Update keyboard UI
            const key = document.querySelector(`.key[data-note="${note}"]`);
            if (key) {
                key.classList.remove('active');
            }
        }
        
        // Send MIDI control change
        function controlChange(cc, value) {
            sendOSC('/midi/cc', [cc, value]);
        }
        
        // Send OSC message through WebSocket
        function sendOSC(address, args) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'osc',
                    address: address,
                    args: args
                };
                
                try {
                    socket.send(JSON.stringify(message));
                    logMessage(`Sent OSC: ${address} ${JSON.stringify(args)}`);
                    return true;
                } catch (err) {
                    logMessage(`Error sending OSC: ${err.message}`);
                    return false;
                }
            } else {
                logMessage('Cannot send OSC: WebSocket not connected');
                return false;
            }
        }
        
        // Create virtual keyboard
        function createKeyboard() {
            const keyboard = document.getElementById('keyboard');
            const startNote = 60; // Middle C
            const numKeys = 24;
            
            // Create white keys first
            for (let i = 0; i < numKeys; i++) {
                const note = startNote + i;
                const octave = Math.floor(note / 12) - 1;
                const noteInOctave = note % 12;
                const isBlack = [1, 3, 6, 8, 10].includes(noteInOctave);
                
                if (!isBlack) {
                    createKey(keyboard, note, getNoteName(note), false);
                }
            }
            
            // Create black keys on top
            for (let i = 0; i < numKeys; i++) {
                const note = startNote + i;
                const octave = Math.floor(note / 12) - 1;
                const noteInOctave = note % 12;
                const isBlack = [1, 3, 6, 8, 10].includes(noteInOctave);
                
                if (isBlack) {
                    createKey(keyboard, note, getNoteName(note), true);
                }
            }
        }
        
        // Create a single key
        function createKey(keyboard, note, noteName, isBlack) {
            const key = document.createElement('div');
            key.className = `key ${isBlack ? 'black' : ''}`;
            key.dataset.note = note;
            key.textContent = noteName;
            
            // Mouse events
            key.addEventListener('mousedown', () => noteOn(note, 100));
            key.addEventListener('mouseup', () => noteOff(note));
            key.addEventListener('mouseleave', () => {
                if (activeNotes.has(note)) noteOff(note);
            });
            
            // Touch events
            key.addEventListener('touchstart', (e) => {
                e.preventDefault();
                noteOn(note, 100);
            });
            key.addEventListener('touchend', (e) => {
                e.preventDefault();
                noteOff(note);
            });
            
            keyboard.appendChild(key);
        }
        
        // Get note name from MIDI note number
        function getNoteName(note) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(note / 12) - 1;
            const noteName = noteNames[note % 12];
            return `${noteName}${octave}`;
        }
        
        // Update connection status displays
        function updateStatus(element, state, message) {
            element.className = `status ${state === 'connected' ? 'connected' : 'disconnected'}`;
            element.textContent = message;
        }
        
        // Log messages to the UI
        function logMessage(message) {
            const p = document.createElement('p');
            const now = new Date();
            p.textContent = `[${now.toLocaleTimeString()}] ${message}`;
            logElement.appendChild(p);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // Key mapping for computer keyboard
        const keyMap = {
            'a': 60, // C4
            'w': 61, // C#4
            's': 62, // D4
            'e': 63, // D#4
            'd': 64, // E4
            'f': 65, // F4
            't': 66, // F#4
            'g': 67, // G4
            'y': 68, // G#4
            'h': 69, // A4
            'u': 70, // A#4
            'j': 71, // B4
            'k': 72, // C5
            'o': 73, // C#5
            'l': 74, // D5
            'p': 75, // D#5
            ';': 76, // E5
            "'": 77  // F5
        };
        
        // Track key states
        const pressedKeys = new Set();
        
        // Handle key down events
        function handleKeyDown(e) {
            // Ignore if key is already pressed or not in our map
            if (pressedKeys.has(e.key) || !keyMap[e.key]) return;
            
            const note = keyMap[e.key];
            noteOn(note, 100);
            pressedKeys.add(e.key);
        }
        
        // Handle key up events
        function handleKeyUp(e) {
            if (!pressedKeys.has(e.key) || !keyMap[e.key]) return;
            
            const note = keyMap[e.key];
            noteOff(note);
            pressedKeys.delete(e.key);
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            // Create the keyboard
            createKeyboard();
            
            // Set up event listeners
            connectWSButton.addEventListener('click', () => {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.close();
                } else {
                    connectWebSocket();
                }
            });
            
            connectMIDIButton.addEventListener('click', initMIDI);
            
            document.getElementById('clearLog').addEventListener('click', () => {
                logElement.innerHTML = '';
                logMessage('Log cleared');
            });
            
            // Controllers
            document.getElementById('modulation').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('modValue').textContent = value;
                controlChange(1, value);
            });
            
            document.getElementById('expression').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('exprValue').textContent = value;
                controlChange(11, value);
            });
            
            // Computer keyboard
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            
            // Try to connect automatically
            setTimeout(connectWebSocket, 500);
            
            logMessage('Application initialized');
        });
        // Add this script before the closing </body> tag in your index.html
// Or save as public/optimized-client.js and include it in your HTML

// Throttling system for MIDI CC messages
const ccThrottles = {};
const lastCCValues = {};

// Optimize CC value sending
function sendOptimizedCC(ccNumber, value) {
    // Don't send if socket is not connected
    if (!socket || socket.readyState !== WebSocket.OPEN) {
        return;
    }
    
    // Skip if this is the same value we just sent
    const key = `cc-${ccNumber}`;
    if (lastCCValues[key] === value) {
        return;
    }
    
    // Check if we're already throttling this CC
    if (ccThrottles[key]) {
        // Update the value but don't send yet
        ccThrottles[key].value = value;
        return;
    }
    
    // Update stored value and send immediately
    lastCCValues[key] = value;
    sendOSC('/midi/cc', [ccNumber, value]);
    
    // Set up throttling for subsequent changes
    ccThrottles[key] = {
        value: value,
        timeoutId: setTimeout(() => {
            const throttle = ccThrottles[key];
            if (throttle && throttle.value !== lastCCValues[key]) {
                // Only send if the value has changed
                lastCCValues[key] = throttle.value;
                sendOSC('/midi/cc', [ccNumber, throttle.value]);
            }
            delete ccThrottles[key];
        }, 15) // 15ms throttle
    };
}

// Replace or enhance the existing controller handling
document.addEventListener('DOMContentLoaded', () => {
    // Get the existing controllers
    const modulation = document.getElementById('modulation');
    const expression = document.getElementById('expression');
    
    if (modulation) {
        // Use optimized version
        modulation.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('modValue').textContent = value;
            // Use optimized throttling
            sendOptimizedCC(1, value);
        });
    }
    
    if (expression) {
        // Use optimized version
        expression.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            document.getElementById('exprValue').textContent = value;
            // Use optimized throttling
            sendOptimizedCC(11, value);
        });
    }
    
    // Enhance keyboard handling
    const keyElements = document.querySelectorAll('.key');
    keyElements.forEach(key => {
        // Convert to touchstart/touchend for better mobile performance
        key.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const note = parseInt(key.dataset.note);
            noteOn(note, 100);
        }, { passive: false });
        
        key.addEventListener('touchend', (e) => {
            e.preventDefault();
            const note = parseInt(key.dataset.note);
            noteOff(note);
        }, { passive: false });
    });
    
    // Add connection status indicator
    const container = document.querySelector('.container');
    if (container) {
        const statusIndicator = document.createElement('div');
        statusIndicator.id = 'performance-indicator';
        statusIndicator.style.padding = '5px';
        statusIndicator.style.marginTop = '10px';
        statusIndicator.style.backgroundColor = '#f0f0f0';
        statusIndicator.style.borderRadius = '4px';
        statusIndicator.textContent = 'MIDI CC Optimization: Enabled';
        container.appendChild(statusIndicator);
    }
    
    // Clean up on unload
    window.addEventListener('beforeunload', () => {
        // Clear all throttle timeouts
        Object.values(ccThrottles).forEach(throttle => {
            if (throttle.timeoutId) {
                clearTimeout(throttle.timeoutId);
            }
        });
    });
});

// Enhanced WebSocket connection with automatic reconnection
function enhancedConnectWebSocket() {
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    const RECONNECT_DELAY = 1000;
    
    function attemptConnection() {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const host = window.location.host;
        const wsUrl = `${protocol}//${host}`;
        
        if (socket && socket.readyState !== WebSocket.CLOSED) {
            socket.close();
        }
        
        logMessage('Connecting to WebSocket...');
        updateStatus(websocketStatus, 'connecting', 'WebSocket: Connecting...');
        
        try {
            socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                logMessage('WebSocket connected');
                updateStatus(websocketStatus, 'connected', 'WebSocket: Connected');
                connectWSButton.textContent = 'Disconnect';
                reconnectAttempts = 0;
            };
            
            socket.onclose = () => {
                logMessage('WebSocket disconnected');
                updateStatus(websocketStatus, 'disconnected', 'WebSocket: Disconnected');
                connectWSButton.textContent = 'Connect to OSC Bridge';
                
                // Try to reconnect with exponential backoff
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    const delay = RECONNECT_DELAY * Math.pow(2, reconnectAttempts);
                    logMessage(`Attempting to reconnect in ${delay}ms`);
                    setTimeout(attemptConnection, delay);
                    reconnectAttempts++;
                } else {
                    logMessage('Maximum reconnection attempts reached. Please reconnect manually.');
                }
            };
            
            socket.onerror = (error) => {
                logMessage(`WebSocket error: ${error.message || 'Unknown error'}`);
                updateStatus(websocketStatus, 'disconnected', 'WebSocket: Connection error');
            };
            
            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Only log a small portion of messages to avoid UI lag
                    if (Math.random() < 0.05) {
                        logMessage(`Received: ${JSON.stringify(data)}`);
                    }
                    
                    // Process different message types
                    if (data.type === 'osc') {
                        processOscMessage(data);
                    }
                } catch (err) {
                    logMessage(`Error parsing message: ${err.message}`);
                }
            };
        } catch (err) {
            logMessage(`Error creating WebSocket: ${err.message}`);
            updateStatus(websocketStatus, 'disconnected', 'WebSocket: Failed to connect');
        }
    }
    
    attemptConnection();
}

// Optimized version of the sendOSC function
function enhancedSendOSC(address, args) {
    if (socket && socket.readyState === WebSocket.OPEN) {
        const message = {
            type: 'osc',
            address: address,
            args: args
        };
        
        try {
            socket.send(JSON.stringify(message));
            // Only log a small percentage of messages to avoid UI lag
            if (Math.random() < 0.01) {
                logMessage(`Sent OSC: ${address} ${JSON.stringify(args)}`);
            }
            return true;
        } catch (err) {
            logMessage(`Error sending OSC: ${err.message}`);
            return false;
        }
    } else {
        // Don't log every time - this could flood the log
        if (Math.random() < 0.1) {
            logMessage('Cannot send OSC: WebSocket not connected');
        }
        return false;
    }
}

// Use these optimized functions in your existing code
// Replace connectWebSocket with enhancedConnectWebSocket
// Replace sendOSC with enhancedSendOSC
    </script>
</body>
</html>
